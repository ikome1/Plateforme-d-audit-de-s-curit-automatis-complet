#!/usr/bin/env python3
# -*- coding: utf-8 -*-
"""
Plateforme d'Audit de S√©curit√© Automatis√© (Network & Web)
Outil de pentest automatis√© : reconnaissance ‚Üí analyse ‚Üí priorisation ‚Üí reporting
"""

import subprocess
import xml.etree.ElementTree as ET
import requests
import argparse
import sys
import os
import json
import re
import socket
from datetime import datetime
from typing import List, Dict, Optional, Tuple, Set
from pathlib import Path
from bs4 import BeautifulSoup
from urllib.parse import urljoin, urlparse, parse_qs
import urllib3
from collections import defaultdict

# D√©sactive les avertissements SSL
urllib3.disable_warnings(urllib3.exceptions.InsecureRequestWarning)

# Codes couleur ANSI
class Colors:
    RESET = '\033[0m'
    BOLD = '\033[1m'
    RED = '\033[91m'
    GREEN = '\033[92m'
    YELLOW = '\033[93m'
    BLUE = '\033[94m'
    MAGENTA = '\033[95m'
    CYAN = '\033[96m'

# ============================================================================
# MODULE 1: RECONNAISSANCE MULTI-CIBLES
# ============================================================================

class ReconnaissanceEngine:
    """Moteur de reconnaissance multi-cibles avec Nmap"""
    
    def __init__(self, targets: List[str], scan_type: str = 'normal', timeout: int = 300):
        self.targets = targets
        self.scan_type = scan_type
        self.timeout = timeout
        self.results = []
    
    def check_nmap_installed(self) -> bool:
        """V√©rifie si Nmap est install√©"""
        try:
            subprocess.run(['nmap', '--version'], capture_output=True, check=True, timeout=5)
            return True
        except:
            return False
    
    def resolve_target(self, target: str) -> Optional[str]:
        """R√©sout un nom de domaine en IP"""
        try:
            if re.match(r'^\d+\.\d+\.\d+\.\d+$', target):
                return target
            return socket.gethostbyname(target)
        except:
            return None
    
    def run_nmap_scan(self, target: str) -> Optional[str]:
        """Lance un scan Nmap et retourne le chemin du fichier XML"""
        if not self.check_nmap_installed():
            print(f"{Colors.RED}[!] Nmap n'est pas install√©{Colors.RESET}")
            return None
        
        xml_file = f"/tmp/nmap_{target.replace('/', '_')}_{datetime.now().strftime('%Y%m%d_%H%M%S')}.xml"
        
        scan_commands = {
            'quick': ['-F', '-T4', '-sV'],
            'normal': ['-p', '1-1000', '-T4', '-sV', '-sC'],
            'comprehensive': ['-p-', '-T4', '-sV', '-sC']
        }
        
        cmd = ['nmap', '-oX', xml_file] + scan_commands.get(self.scan_type, scan_commands['normal']) + [target]
        
        try:
            result = subprocess.run(cmd, capture_output=True, text=True, timeout=self.timeout)
            if os.path.exists(xml_file):
                return xml_file
        except subprocess.TimeoutExpired:
            print(f"{Colors.YELLOW}[!] Scan timeout pour {target}{Colors.RESET}")
        except Exception as e:
            print(f"{Colors.RED}[!] Erreur lors du scan de {target}: {e}{Colors.RESET}")
        
        return None
    
    def parse_nmap_xml(self, xml_file: str) -> Optional[Dict]:
        """Parse les r√©sultats XML de Nmap"""
        if not os.path.exists(xml_file):
            return None
        
        try:
            tree = ET.parse(xml_file)
            root = tree.getroot()
            
            result = {
                'target': '',
                'status': {},
                'addresses': [],
                'os': None,
                'ports': [],
                'web_services': []
            }
            
            for host in root.findall('host'):
                # Adresses
                for address in host.findall('address'):
                    addr = address.get('addr')
                    addrtype = address.get('addrtype')
                    result['addresses'].append({'addr': addr, 'type': addrtype})
                    if addrtype == 'ipv4':
                        result['target'] = addr
                
                # Statut
                status = host.find('status')
                if status is not None:
                    result['status'] = {'state': status.get('state'), 'reason': status.get('reason')}
                
                # OS
                os_match = host.find('os/osmatch')
                if os_match is not None:
                    result['os'] = {'name': os_match.get('name'), 'accuracy': os_match.get('accuracy')}
                
                # Ports et services
                for port in host.findall('.//port'):
                    state = port.find('state')
                    if state is not None and state.get('state') == 'open':
                        port_data = {
                            'portid': port.get('portid'),
                            'protocol': port.get('protocol'),
                            'service': {}
                        }
                        
                        service = port.find('service')
                        if service is not None:
                            port_data['service'] = {
                                'name': service.get('name', 'unknown'),
                                'product': service.get('product', ''),
                                'version': service.get('version', ''),
                                'extrainfo': service.get('extrainfo', '')
                            }
                            
                            # Identifie les services web
                            service_name = port_data['service']['name'].lower()
                            if service_name in ['http', 'https', 'http-proxy', 'ssl/http']:
                                portid = port_data['portid']
                                scheme = 'https' if 'ssl' in service_name or portid == '443' else 'http'
                                url = f"{scheme}://{result['target']}:{portid}"
                                result['web_services'].append({
                                    'url': url,
                                    'port': portid,
                                    'service': port_data['service']
                                })
                        
                        result['ports'].append(port_data)
            
            # Nettoie le fichier XML temporaire
            try:
                os.remove(xml_file)
            except:
                pass
            
            return result
            
        except Exception as e:
            print(f"{Colors.RED}[!] Erreur parsing XML: {e}{Colors.RESET}")
            return None
    
    def scan_targets(self) -> List[Dict]:
        """Scanne tous les targets"""
        print(f"{Colors.CYAN}{'='*80}{Colors.RESET}")
        print(f"{Colors.BOLD}PHASE 1: RECONNAISSANCE{Colors.RESET}")
        print(f"{Colors.CYAN}{'='*80}{Colors.RESET}\n")
        
        print(f"{Colors.BLUE}[*] Cibles √† scanner: {len(self.targets)}{Colors.RESET}")
        print(f"{Colors.BLUE}[*] Type de scan: {self.scan_type}{Colors.RESET}\n")
        
        results = []
        
        for i, target in enumerate(self.targets, 1):
            print(f"{Colors.CYAN}[{i}/{len(self.targets)}] Scan de {target}...{Colors.RESET}")
            
            # R√©sout le target
            ip = self.resolve_target(target)
            if not ip:
                print(f"  {Colors.RED}[!] Impossible de r√©soudre {target}{Colors.RESET}\n")
                continue
            
            if ip != target:
                print(f"  {Colors.GREEN}[+] {target} ‚Üí {ip}{Colors.RESET}")
            
            # Lance le scan
            xml_file = self.run_nmap_scan(target)
            if not xml_file:
                print(f"  {Colors.RED}[!] √âchec du scan{Colors.RESET}\n")
                continue
            
            # Parse les r√©sultats
            result = self.parse_nmap_xml(xml_file)
            if result:
                result['original_target'] = target
                results.append(result)
                ports_count = len(result['ports'])
                web_count = len(result['web_services'])
                print(f"  {Colors.GREEN}[+] {ports_count} port(s) ouvert(s), {web_count} service(s) web{Colors.RESET}")
            else:
                print(f"  {Colors.YELLOW}[!] Aucun r√©sultat pars√©{Colors.RESET}")
            
            print()
        
        self.results = results
        return results

# ============================================================================
# MODULE 2: ANALYSE INTELLIGENTE DES SERVICES
# ============================================================================

class ServiceAnalyzer:
    """Analyse intelligente des services d√©tect√©s"""
    
    VULNERABLE_VERSIONS = {
        'ssh': {'old': ['OpenSSH 5', 'OpenSSH 4', 'OpenSSH 3'], 'min': 'OpenSSH 7.0'},
        'apache': {'old': ['Apache 2.0', 'Apache 2.2'], 'min': 'Apache 2.4.41'},
        'nginx': {'old': ['nginx 1.0', 'nginx 1.2'], 'min': 'nginx 1.18'},
        'mysql': {'old': ['MySQL 5.0', 'MySQL 5.1'], 'min': 'MySQL 5.7'},
        'ftp': {'old': ['vsftpd 2.0'], 'min': 'vsftpd 3.0'}
    }
    
    INSECURE_SERVICES = {
        'telnet': {'port': 23, 'risk': 'critical', 'desc': 'Service non chiffr√©'},
        'ftp': {'port': 21, 'risk': 'high', 'desc': 'FTP non s√©curis√©'},
        'http': {'port': 80, 'risk': 'medium', 'desc': 'HTTP non chiffr√©'}
    }
    
    def __init__(self):
        self.findings = []
    
    def analyze_service(self, port: Dict, target_ip: str) -> Optional[Dict]:
        """Analyse un service individuel"""
        service_name = port['service'].get('name', '').lower()
        product = port['service'].get('product', '')
        version = port['service'].get('version', '')
        full_version = f"{product} {version}".strip()
        portid = port['portid']
        
        findings = []
        
        # V√©rifie les services non s√©curis√©s
        if service_name in self.INSECURE_SERVICES:
            info = self.INSECURE_SERVICES[service_name]
            findings.append({
                'type': 'insecure_service',
                'severity': info['risk'],
                'description': f"{service_name.upper()} non s√©curis√© - {info['desc']}",
                'port': portid,
                'recommendation': f"Remplacer par une alternative s√©curis√©e (ex: SFTP pour FTP, SSH pour Telnet)"
            })
        
        # V√©rifie les versions obsol√®tes
        for svc_type, vuln_info in self.VULNERABLE_VERSIONS.items():
            if svc_type in service_name or svc_type in product.lower():
                for old_version in vuln_info['old']:
                    if old_version.lower() in full_version.lower():
                        findings.append({
                            'type': 'obsolete_version',
                            'severity': 'high',
                            'description': f"Version obsol√®te d√©tect√©e: {full_version}",
                            'port': portid,
                            'service': service_name,
                            'recommendation': f"Mettre √† jour vers {vuln_info['min']} ou sup√©rieur"
                        })
                        break
        
        # D√©tecte les ports sensibles
        sensitive_ports = {
            '22': {'service': 'SSH', 'risk': 'medium', 'desc': 'Acc√®s √† distance - V√©rifier la configuration'},
            '3389': {'service': 'RDP', 'risk': 'high', 'desc': 'Acc√®s bureau √† distance - Activer NLA'},
            '445': {'service': 'SMB', 'risk': 'high', 'desc': 'Partage de fichiers - V√©rifier SMBv1'},
            '1433': {'service': 'MSSQL', 'risk': 'medium', 'desc': 'Base de donn√©es - Restreindre l\'acc√®s'},
            '3306': {'service': 'MySQL', 'risk': 'medium', 'desc': 'Base de donn√©es - Restreindre l\'acc√®s'}
        }
        
        if portid in sensitive_ports:
            info = sensitive_ports[portid]
            findings.append({
                'type': 'sensitive_port',
                'severity': info['risk'],
                'description': f"Port sensible {portid} ({info['service']}) ouvert - {info['desc']}",
                'port': portid,
                'recommendation': 'V√©rifier la configuration et restreindre l\'acc√®s si possible'
            })
        
        if findings:
            return {
                'target': target_ip,
                'port': portid,
                'service': service_name,
                'findings': findings
            }
        
        return None
    
    def analyze_all(self, reconnaissance_results: List[Dict]) -> List[Dict]:
        """Analyse tous les services d√©tect√©s"""
        print(f"{Colors.CYAN}{'='*80}{Colors.RESET}")
        print(f"{Colors.BOLD}PHASE 2: ANALYSE DES SERVICES{Colors.RESET}")
        print(f"{Colors.CYAN}{'='*80}{Colors.RESET}\n")
        
        all_findings = []
        
        for result in reconnaissance_results:
            target = result.get('target', 'unknown')
            ports = result.get('ports', [])
            
            if not ports:
                continue
            
            print(f"{Colors.BLUE}[*] Analyse de {target} ({len(ports)} port(s)){Colors.RESET}")
            
            for port in ports:
                analysis = self.analyze_service(port, target)
                if analysis:
                    all_findings.append(analysis)
                    for finding in analysis['findings']:
                        severity_color = {
                            'critical': Colors.RED,
                            'high': Colors.YELLOW,
                            'medium': Colors.BLUE,
                            'low': Colors.GREEN
                        }.get(finding['severity'], Colors.RESET)
                        print(f"  {severity_color}[{finding['severity'].upper()}] Port {port['portid']}: {finding['description']}{Colors.RESET}")
            
            print()
        
        self.findings = all_findings
        return all_findings

# ============================================================================
# MODULE 3: AUDIT DE S√âCURIT√â WEB
# ============================================================================

class WebAuditor:
    """Audit de s√©curit√© web automatis√©"""
    
    XSS_PAYLOADS = [
        '<script>alert("XSS")</script>',
        '<img src=x onerror=alert("XSS")>',
        '"><script>alert("XSS")</script>'
    ]
    
    SQLI_PAYLOADS = [
        "' OR '1'='1",
        "' UNION SELECT NULL--",
        "admin' --"
    ]
    
    SENSITIVE_ENDPOINTS = [
        '/admin', '/administrator', '/wp-admin', '/phpmyadmin',
        '/.env', '/.git', '/config.php', '/backup.sql',
        '/api/admin', '/api/v1', '/upload', '/file/upload'
    ]
    
    SECURITY_HEADERS = ['Content-Security-Policy', 'Strict-Transport-Security',
                       'X-Frame-Options', 'X-Content-Type-Options', 'X-XSS-Protection']
    
    def __init__(self, timeout: int = 10, verify_ssl: bool = False):
        self.timeout = timeout
        self.verify_ssl = verify_ssl
        self.session = requests.Session()
        self.session.verify = verify_ssl
        self.session.headers.update({
            'User-Agent': 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36'
        })
        self.web_findings = []
    
    def check_security_headers(self, url: str, response: requests.Response) -> List[Dict]:
        """V√©rifie les headers de s√©curit√©"""
        findings = []
        missing_headers = []
        
        for header in self.SECURITY_HEADERS:
            if header not in response.headers:
                missing_headers.append(header)
        
        if missing_headers:
            findings.append({
                'type': 'missing_security_headers',
                'severity': 'medium',
                'description': f"Headers de s√©curit√© manquants: {', '.join(missing_headers)}",
                'url': url,
                'recommendation': 'Impl√©menter les headers de s√©curit√© recommand√©s (CSP, HSTS, X-Frame-Options, etc.)'
            })
        
        # V√©rifie la configuration HSTS
        if 'Strict-Transport-Security' in response.headers:
            hsts = response.headers['Strict-Transport-Security'].lower()
            if 'max-age' not in hsts:
                findings.append({
                    'type': 'hsts_misconfigured',
                    'severity': 'low',
                    'description': 'HSTS pr√©sent mais max-age manquant',
                    'url': url,
                    'recommendation': 'Ajouter max-age=31536000 √† HSTS'
                })
        
        return findings
    
    def test_xss_in_form(self, form: Dict, base_url: str) -> Optional[Dict]:
        """Teste XSS dans un formulaire"""
        for payload in self.XSS_PAYLOADS[:2]:  # Limite pour √©viter trop de requ√™tes
            try:
                data = {}
                for input_field in form.get('inputs', []):
                    if input_field.get('name'):
                        data[input_field['name']] = payload
                
                if form['method'] == 'POST':
                    response = self.session.post(form['action'], data=data, timeout=self.timeout)
                else:
                    response = self.session.get(form['action'], params=data, timeout=self.timeout)
                
                if payload in response.text or '<script>' in response.text.lower():
                    return {
                        'type': 'xss_vulnerability',
                        'severity': 'high',
                        'description': f'XSS potentiel d√©tect√© dans le formulaire {form["action"]}',
                        'url': form['action'],
                        'payload': payload,
                        'recommendation': 'Valider et √©chapper toutes les entr√©es utilisateur, utiliser CSP'
                    }
            except:
                continue
        return None
    
    def test_sqli_in_form(self, form: Dict, base_url: str) -> Optional[Dict]:
        """Teste SQLi dans un formulaire"""
        for payload in self.SQLI_PAYLOADS[:2]:
            try:
                data = {}
                for input_field in form.get('inputs', []):
                    if input_field.get('name'):
                        data[input_field['name']] = payload
                
                if form['method'] == 'POST':
                    response = self.session.post(form['action'], data=data, timeout=self.timeout)
                else:
                    response = self.session.get(form['action'], params=data, timeout=self.timeout)
                
                sql_errors = ['sql syntax', 'mysql_fetch', 'mysqli_query', 'pg_query']
                if any(error in response.text.lower() for error in sql_errors):
                    return {
                        'type': 'sqli_vulnerability',
                        'severity': 'critical',
                        'description': f'SQL Injection potentielle d√©tect√©e dans {form["action"]}',
                        'url': form['action'],
                        'payload': payload,
                        'recommendation': 'Utiliser des requ√™tes pr√©par√©es (prepared statements), valider les entr√©es'
                    }
            except:
                continue
        return None
    
    def enumerate_endpoints(self, base_url: str) -> List[Dict]:
        """√ânum√®re les endpoints sensibles"""
        findings = []
        
        for endpoint in self.SENSITIVE_ENDPOINTS[:10]:  # Limite pour √©viter trop de requ√™tes
            url = urljoin(base_url.rstrip('/'), endpoint)
            try:
                response = self.session.get(url, timeout=self.timeout, allow_redirects=False)
                if response.status_code == 200:
                    findings.append({
                        'type': 'sensitive_endpoint',
                        'severity': 'medium',
                        'description': f'Endpoint sensible accessible: {endpoint}',
                        'url': url,
                        'status_code': response.status_code,
                        'recommendation': 'Restreindre l\'acc√®s √† cet endpoint ou le supprimer si non n√©cessaire'
                    })
            except:
                continue
        
        return findings
    
    def audit_web_service(self, web_service: Dict) -> List[Dict]:
        """Audit complet d'un service web"""
        url = web_service['url']
        findings = []
        
        try:
            print(f"  {Colors.BLUE}[*] Audit de {url}...{Colors.RESET}")
            
            response = self.session.get(url, timeout=self.timeout, allow_redirects=True)
            
            # V√©rifie les headers de s√©curit√©
            findings.extend(self.check_security_headers(url, response))
            
            # Trouve les formulaires
            soup = BeautifulSoup(response.text, 'html.parser')
            forms = []
            
            for form in soup.find_all('form'):
                form_data = {
                    'action': urljoin(url, form.get('action', '')),
                    'method': form.get('method', 'GET').upper(),
                    'inputs': []
                }
                
                for input_tag in form.find_all(['input', 'textarea', 'select']):
                    if input_tag.get('name'):
                        form_data['inputs'].append({
                            'name': input_tag.get('name'),
                            'type': input_tag.get('type', 'text')
                        })
                
                forms.append(form_data)
            
            # Teste les formulaires
            for form in forms:
                xss_result = self.test_xss_in_form(form, url)
                if xss_result:
                    findings.append(xss_result)
                
                sqli_result = self.test_sqli_in_form(form, url)
                if sqli_result:
                    findings.append(sqli_result)
            
            # √ânum√®re les endpoints sensibles
            findings.extend(self.enumerate_endpoints(url))
            
            if findings:
                print(f"    {Colors.YELLOW}[!] {len(findings)} probl√®me(s) d√©tect√©(s){Colors.RESET}")
            else:
                print(f"    {Colors.GREEN}[+] Aucun probl√®me d√©tect√©{Colors.RESET}")
            
        except Exception as e:
            print(f"    {Colors.RED}[!] Erreur lors de l'audit: {e}{Colors.RESET}")
        
        return findings
    
    def audit_all(self, reconnaissance_results: List[Dict]) -> List[Dict]:
        """Audit tous les services web d√©tect√©s"""
        print(f"{Colors.CYAN}{'='*80}{Colors.RESET}")
        print(f"{Colors.BOLD}PHASE 3: AUDIT WEB{Colors.RESET}")
        print(f"{Colors.CYAN}{'='*80}{Colors.RESET}\n")
        
        all_web_findings = []
        web_services_count = 0
        
        for result in reconnaissance_results:
            web_services = result.get('web_services', [])
            if not web_services:
                continue
            
            web_services_count += len(web_services)
            
            for web_service in web_services:
                findings = self.audit_web_service(web_service)
                if findings:
                    for finding in findings:
                        finding['target'] = result.get('target', 'unknown')
                    all_web_findings.extend(findings)
            
            print()
        
        if web_services_count == 0:
            print(f"{Colors.YELLOW}[!] Aucun service web d√©tect√©{Colors.RESET}\n")
        
        self.web_findings = all_web_findings
        return all_web_findings

# ============================================================================
# MODULE 4: CORR√âLATION & SCORING DES RISQUES
# ============================================================================

class RiskScorer:
    """Syst√®me de scoring et priorisation des risques"""
    
    SEVERITY_WEIGHTS = {
        'critical': 10,
        'high': 7,
        'medium': 4,
        'low': 1
    }
    
    def __init__(self):
        self.scored_findings = []
    
    def deduplicate_findings(self, findings: List[Dict]) -> List[Dict]:
        """√âvite les faux positifs et d√©duplique"""
        seen = set()
        unique_findings = []
        
        for finding in findings:
            # Cr√©e une cl√© unique pour chaque finding
            if 'url' in finding:
                key = f"{finding.get('target', '')}:{finding['url']}:{finding.get('type', '')}"
            elif 'port' in finding:
                key = f"{finding.get('target', '')}:{finding['port']}:{finding.get('type', '')}"
            else:
                key = f"{finding.get('target', '')}:{finding.get('type', '')}"
            
            if key not in seen:
                seen.add(key)
                unique_findings.append(finding)
        
        return unique_findings
    
    def calculate_risk_score(self, finding: Dict) -> int:
        """Calcule un score de risque pour un finding"""
        severity = finding.get('severity', 'low')
        base_score = self.SEVERITY_WEIGHTS.get(severity, 1)
        
        # Bonus pour les findings critiques
        if finding.get('type') in ['sqli_vulnerability', 'xss_vulnerability']:
            base_score += 2
        
        # Bonus pour les ports sensibles
        if finding.get('type') == 'sensitive_port':
            base_score += 1
        
        return base_score
    
    def prioritize_findings(self, service_findings: List[Dict], web_findings: List[Dict]) -> Dict:
        """Priorise tous les findings"""
        print(f"{Colors.CYAN}{'='*80}{Colors.RESET}")
        print(f"{Colors.BOLD}PHASE 4: SCORING & PRIORISATION DES RISQUES{Colors.RESET}")
        print(f"{Colors.CYAN}{'='*80}{Colors.RESET}\n")
        
        # Combine tous les findings
        all_findings = []
        
        for finding_group in service_findings:
            for finding in finding_group.get('findings', []):
                finding['target'] = finding_group.get('target', 'unknown')
                finding['port'] = finding_group.get('port', '')
                all_findings.append(finding)
        
        all_findings.extend(web_findings)
        
        # D√©duplique
        unique_findings = self.deduplicate_findings(all_findings)
        
        print(f"{Colors.BLUE}[*] Findings totaux: {len(all_findings)}{Colors.RESET}")
        print(f"{Colors.BLUE}[*] Findings uniques: {len(unique_findings)}{Colors.RESET}\n")
        
        # Calcule les scores et groupe par s√©v√©rit√©
        scored_findings = []
        for finding in unique_findings:
            finding['risk_score'] = self.calculate_risk_score(finding)
            scored_findings.append(finding)
        
        # Trie par score d√©croissant
        scored_findings.sort(key=lambda x: x['risk_score'], reverse=True)
        
        # Groupe par s√©v√©rit√©
        prioritized = {
            'critical': [],
            'high': [],
            'medium': [],
            'low': []
        }
        
        for finding in scored_findings:
            severity = finding.get('severity', 'low')
            prioritized[severity].append(finding)
        
        # Affiche le r√©sum√©
        for severity in ['critical', 'high', 'medium', 'low']:
            count = len(prioritized[severity])
            color = {
                'critical': Colors.RED,
                'high': Colors.YELLOW,
                'medium': Colors.BLUE,
                'low': Colors.GREEN
            }.get(severity, Colors.RESET)
            print(f"  {color}[{severity.upper()}] {count} finding(s){Colors.RESET}")
        
        print()
        
        self.scored_findings = scored_findings
        return {
            'prioritized': prioritized,
            'all_findings': scored_findings,
            'summary': {
                'total': len(scored_findings),
                'critical': len(prioritized['critical']),
                'high': len(prioritized['high']),
                'medium': len(prioritized['medium']),
                'low': len(prioritized['low'])
            }
        }

# ============================================================================
# MODULE 5: REPORTING PROFESSIONNEL
# ============================================================================

class ReportGenerator:
    """G√©n√©rateur de rapports professionnels"""
    
    def __init__(self, reconnaissance_results: List[Dict], risk_analysis: Dict, output_dir: str = 'reports'):
        self.recon_results = reconnaissance_results
        self.risk_analysis = risk_analysis
        self.output_dir = output_dir
        self.timestamp = datetime.now().strftime('%Y%m%d_%H%M%S')
        
        if not Path(output_dir).exists():
            Path(output_dir).mkdir(parents=True)
    
    def generate_txt_report(self) -> str:
        """G√©n√®re un rapport texte professionnel"""
        filename = Path(self.output_dir) / f'rapport_pentest_{self.timestamp}.txt'
        
        with open(filename, 'w', encoding='utf-8') as f:
            # En-t√™te
            f.write("=" * 80 + "\n")
            f.write("RAPPORT D'AUDIT DE S√âCURIT√â - PENTEST AUTOMATIS√â\n")
            f.write("=" * 80 + "\n\n")
            f.write(f"Date: {datetime.now().strftime('%Y-%m-%d %H:%M:%S')}\n")
            f.write(f"G√©n√©r√© par: Plateforme d'Audit de S√©curit√© Automatis√©\n\n")
            
            # R√©sum√© ex√©cutif
            f.write("=" * 80 + "\n")
            f.write("R√âSUM√â EX√âCUTIF\n")
            f.write("=" * 80 + "\n\n")
            
            summary = self.risk_analysis.get('summary', {})
            f.write(f"Cibles analys√©es: {len(self.recon_results)}\n")
            f.write(f"Findings totaux: {summary.get('total', 0)}\n")
            f.write(f"  - CRITIQUE: {summary.get('critical', 0)}\n")
            f.write(f"  - √âLEV√â:    {summary.get('high', 0)}\n")
            f.write(f"  - MOYEN:    {summary.get('medium', 0)}\n")
            f.write(f"  - FAIBLE:   {summary.get('low', 0)}\n\n")
            
            # D√©tails techniques par s√©v√©rit√©
            prioritized = self.risk_analysis.get('prioritized', {})
            
            for severity in ['critical', 'high', 'medium', 'low']:
                findings = prioritized.get(severity, [])
                if not findings:
                    continue
                
                f.write("=" * 80 + "\n")
                f.write(f"[{severity.upper()}] - {len(findings)} FINDING(S)\n")
                f.write("=" * 80 + "\n\n")
                
                for i, finding in enumerate(findings, 1):
                    f.write(f"{i}. {finding.get('type', 'Unknown').upper().replace('_', ' ')}\n")
                    f.write(f"   Description: {finding.get('description', 'N/A')}\n")
                    
                    if finding.get('target'):
                        f.write(f"   Cible: {finding['target']}\n")
                    if finding.get('port'):
                        f.write(f"   Port: {finding['port']}\n")
                    if finding.get('url'):
                        f.write(f"   URL: {finding['url']}\n")
                    if finding.get('payload'):
                        f.write(f"   Payload: {finding['payload']}\n")
                    
                    f.write(f"   Score de risque: {finding.get('risk_score', 0)}\n")
                    f.write(f"   Recommandation: {finding.get('recommendation', 'N/A')}\n\n")
            
            # Recommandations g√©n√©rales
            f.write("=" * 80 + "\n")
            f.write("RECOMMANDATIONS G√âN√âRALES\n")
            f.write("=" * 80 + "\n\n")
            
            if summary.get('critical', 0) > 0:
                f.write("1. URGENT - Corriger imm√©diatement tous les findings CRITIQUES\n")
                f.write("   - Vuln√©rabilit√©s SQL Injection\n")
                f.write("   - Services non s√©curis√©s critiques\n\n")
            
            if summary.get('high', 0) > 0:
                f.write("2. IMPORTANT - Corriger les findings √âLEV√âS dans les plus brefs d√©lais\n")
                f.write("   - Vuln√©rabilit√©s XSS\n")
                f.write("   - Versions obsol√®tes de services\n")
                f.write("   - Services non s√©curis√©s\n\n")
            
            f.write("3. Am√©liorer la configuration de s√©curit√©\n")
            f.write("   - Impl√©menter les headers de s√©curit√© (CSP, HSTS, etc.)\n")
            f.write("   - Mettre √† jour les services obsol√®tes\n")
            f.write("   - D√©sactiver les services non n√©cessaires\n\n")
            
            f.write("4. Surveillance continue\n")
            f.write("   - Mettre en place un monitoring de s√©curit√©\n")
            f.write("   - Effectuer des audits r√©guliers\n")
            f.write("   - Appliquer le principe du moindre privil√®ge\n\n")
            
            f.write("=" * 80 + "\n")
            f.write("FIN DU RAPPORT\n")
            f.write("=" * 80 + "\n")
        
        return str(filename)
    
    def generate_json_report(self) -> str:
        """G√©n√®re un rapport JSON structur√©"""
        filename = Path(self.output_dir) / f'rapport_pentest_{self.timestamp}.json'
        
        report = {
            'metadata': {
                'report_date': datetime.now().isoformat(),
                'report_version': '1.0',
                'tool': 'Plateforme d\'Audit de S√©curit√© Automatis√©'
            },
            'reconnaissance': self.recon_results,
            'risk_analysis': self.risk_analysis,
            'summary': {
                'targets_analyzed': len(self.recon_results),
                **self.risk_analysis.get('summary', {})
            }
        }
        
        with open(filename, 'w', encoding='utf-8') as f:
            json.dump(report, f, indent=2, ensure_ascii=False, default=str)
        
        return str(filename)
    
    def generate_html_report(self) -> str:
        """G√©n√®re un rapport HTML professionnel"""
        filename = Path(self.output_dir) / f'rapport_pentest_{self.timestamp}.html'
        
        summary = self.risk_analysis.get('summary', {})
        prioritized = self.risk_analysis.get('prioritized', {})
        
        html = f"""<!DOCTYPE html>
<html lang="fr">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Rapport d'Audit de S√©curit√©</title>
    <style>
        body {{ font-family: Arial, sans-serif; margin: 20px; background: #f5f5f5; }}
        .container {{ max-width: 1200px; margin: 0 auto; background: white; padding: 30px; box-shadow: 0 0 10px rgba(0,0,0,0.1); }}
        h1 {{ color: #2c3e50; border-bottom: 3px solid #3498db; padding-bottom: 10px; }}
        h2 {{ color: #34495e; margin-top: 30px; }}
        .summary {{ background: #ecf0f1; padding: 20px; border-radius: 5px; margin: 20px 0; }}
        .severity-critical {{ background: #e74c3c; color: white; padding: 10px; margin: 10px 0; border-radius: 5px; }}
        .severity-high {{ background: #e67e22; color: white; padding: 10px; margin: 10px 0; border-radius: 5px; }}
        .severity-medium {{ background: #3498db; color: white; padding: 10px; margin: 10px 0; border-radius: 5px; }}
        .severity-low {{ background: #2ecc71; color: white; padding: 10px; margin: 10px 0; border-radius: 5px; }}
        .finding {{ background: #fff; border-left: 4px solid #3498db; padding: 15px; margin: 15px 0; box-shadow: 0 2px 4px rgba(0,0,0,0.1); }}
        .finding-title {{ font-weight: bold; color: #2c3e50; margin-bottom: 10px; }}
        .finding-detail {{ margin: 5px 0; color: #555; }}
        .recommendation {{ background: #fff3cd; padding: 10px; border-left: 4px solid #ffc107; margin-top: 10px; }}
        table {{ width: 100%; border-collapse: collapse; margin: 20px 0; }}
        th, td {{ padding: 12px; text-align: left; border-bottom: 1px solid #ddd; }}
        th {{ background: #3498db; color: white; }}
        .footer {{ margin-top: 40px; padding-top: 20px; border-top: 2px solid #ecf0f1; text-align: center; color: #7f8c8d; }}
    </style>
</head>
<body>
    <div class="container">
        <h1>üîí Rapport d'Audit de S√©curit√© - Pentest Automatis√©</h1>
        
        <div class="summary">
            <h2>R√©sum√© Ex√©cutif</h2>
            <p><strong>Date:</strong> {datetime.now().strftime('%Y-%m-%d %H:%M:%S')}</p>
            <p><strong>Cibles analys√©es:</strong> {len(self.recon_results)}</p>
            <p><strong>Findings totaux:</strong> {summary.get('total', 0)}</p>
            <table>
                <tr>
                    <th>S√©v√©rit√©</th>
                    <th>Nombre</th>
                </tr>
                <tr class="severity-critical"><td>CRITIQUE</td><td>{summary.get('critical', 0)}</td></tr>
                <tr class="severity-high"><td>√âLEV√â</td><td>{summary.get('high', 0)}</td></tr>
                <tr class="severity-medium"><td>MOYEN</td><td>{summary.get('medium', 0)}</td></tr>
                <tr class="severity-low"><td>FAIBLE</td><td>{summary.get('low', 0)}</td></tr>
            </table>
        </div>
"""
        
        # Ajoute les findings par s√©v√©rit√©
        for severity in ['critical', 'high', 'medium', 'low']:
            findings = prioritized.get(severity, [])
            if not findings:
                continue
            
            severity_class = f'severity-{severity}'
            severity_name = severity.upper()
            
            html += f"""
        <h2>[{severity_name}] - {len(findings)} Finding(s)</h2>
"""
            
            for i, finding in enumerate(findings, 1):
                html += f"""
        <div class="finding">
            <div class="finding-title">{i}. {finding.get('type', 'Unknown').upper().replace('_', ' ')}</div>
            <div class="finding-detail"><strong>Description:</strong> {finding.get('description', 'N/A')}</div>
"""
                if finding.get('target'):
                    html += f'            <div class="finding-detail"><strong>Cible:</strong> {finding["target"]}</div>\n'
                if finding.get('port'):
                    html += f'            <div class="finding-detail"><strong>Port:</strong> {finding["port"]}</div>\n'
                if finding.get('url'):
                    html += f'            <div class="finding-detail"><strong>URL:</strong> {finding["url"]}</div>\n'
                if finding.get('payload'):
                    html += f'            <div class="finding-detail"><strong>Payload:</strong> <code>{finding["payload"]}</code></div>\n'
                
                html += f'            <div class="finding-detail"><strong>Score de risque:</strong> {finding.get("risk_score", 0)}</div>\n'
                html += f"""
            <div class="recommendation">
                <strong>Recommandation:</strong> {finding.get('recommendation', 'N/A')}
            </div>
        </div>
"""
        
        # Recommandations g√©n√©rales
        html += """
        <h2>Recommandations G√©n√©rales</h2>
        <div class="finding">
            <ul>
                <li><strong>Urgent:</strong> Corriger imm√©diatement tous les findings CRITIQUES</li>
                <li><strong>Important:</strong> Corriger les findings √âLEV√âS dans les plus brefs d√©lais</li>
                <li><strong>Am√©lioration:</strong> Impl√©menter les headers de s√©curit√© et mettre √† jour les services</li>
                <li><strong>Surveillance:</strong> Mettre en place un monitoring de s√©curit√© continu</li>
            </ul>
        </div>
        
        <div class="footer">
            <p>G√©n√©r√© par Plateforme d'Audit de S√©curit√© Automatis√©</p>
            <p>¬© 2024 - Rapport confidentiel</p>
        </div>
    </div>
</body>
</html>
"""
        
        with open(filename, 'w', encoding='utf-8') as f:
            f.write(html)
        
        return str(filename)

# ============================================================================
# MAIN - ORCHESTRATEUR PRINCIPAL
# ============================================================================

def main():
    parser = argparse.ArgumentParser(
        description='Plateforme d\'Audit de S√©curit√© Automatis√© (Network & Web)',
        formatter_class=argparse.RawDescriptionHelpFormatter,
        epilog="""
Exemples d'utilisation:
  python pentest_platform.py 192.168.1.1 192.168.1.2
  python pentest_platform.py example.com --scan-type comprehensive
  python pentest_platform.py 192.168.1.0/24 --output-dir results
  python pentest_platform.py target.com --html
        """
    )
    
    parser.add_argument('targets', nargs='+', help='Cibles √† scanner (IPs ou domaines)')
    parser.add_argument('--scan-type', '-t', 
                       choices=['quick', 'normal', 'comprehensive'],
                       default='normal',
                       help='Type de scan Nmap (d√©faut: normal)')
    parser.add_argument('--timeout', type=int, default=300,
                       help='Timeout pour les scans Nmap en secondes (d√©faut: 300)')
    parser.add_argument('--output-dir', '-o',
                       default='reports',
                       help='R√©pertoire de sortie (d√©faut: reports)')
    parser.add_argument('--txt-only', action='store_true',
                       help='G√©n√©rer uniquement le rapport TXT')
    parser.add_argument('--json-only', action='store_true',
                       help='G√©n√©rer uniquement le rapport JSON')
    parser.add_argument('--html', action='store_true',
                       help='G√©n√©rer √©galement le rapport HTML')
    parser.add_argument('--verify-ssl', action='store_true',
                       help='V√©rifier les certificats SSL')
    
    args = parser.parse_args()
    
    print(f"{Colors.BOLD}{Colors.CYAN}")
    print("=" * 80)
    print("  PLATEFORME D'AUDIT DE S√âCURIT√â AUTOMATIS√â")
    print("  Network & Web Pentest - Version 1.0")
    print("=" * 80)
    print(f"{Colors.RESET}\n")
    
    # Phase 1: Reconnaissance
    recon = ReconnaissanceEngine(args.targets, args.scan_type, args.timeout)
    recon_results = recon.scan_targets()
    
    if not recon_results:
        print(f"{Colors.RED}[!] Aucun r√©sultat de reconnaissance{Colors.RESET}")
        sys.exit(1)
    
    # Phase 2: Analyse des services
    service_analyzer = ServiceAnalyzer()
    service_findings = service_analyzer.analyze_all(recon_results)
    
    # Phase 3: Audit web
    web_auditor = WebAuditor(verify_ssl=args.verify_ssl)
    web_findings = web_auditor.audit_all(recon_results)
    
    # Phase 4: Scoring et priorisation
    risk_scorer = RiskScorer()
    risk_analysis = risk_scorer.prioritize_findings(service_findings, web_findings)
    
    # Phase 5: G√©n√©ration de rapports
    print(f"{Colors.CYAN}{'='*80}{Colors.RESET}")
    print(f"{Colors.BOLD}PHASE 5: G√âN√âRATION DE RAPPORTS{Colors.RESET}")
    print(f"{Colors.CYAN}{'='*80}{Colors.RESET}\n")
    
    report_gen = ReportGenerator(recon_results, risk_analysis, args.output_dir)
    
    reports_generated = []
    
    if not args.json_only:
        txt_file = report_gen.generate_txt_report()
        reports_generated.append(txt_file)
        print(f"{Colors.GREEN}[+] Rapport TXT g√©n√©r√©: {txt_file}{Colors.RESET}")
    
    if not args.txt_only:
        json_file = report_gen.generate_json_report()
        reports_generated.append(json_file)
        print(f"{Colors.GREEN}[+] Rapport JSON g√©n√©r√©: {json_file}{Colors.RESET}")
    
    if args.html:
        html_file = report_gen.generate_html_report()
        reports_generated.append(html_file)
        print(f"{Colors.GREEN}[+] Rapport HTML g√©n√©r√©: {html_file}{Colors.RESET}")
    
    print()
    print(f"{Colors.BOLD}{Colors.GREEN}[+] Audit termin√© avec succ√®s!{Colors.RESET}")
    print(f"{Colors.CYAN}[*] {len(reports_generated)} rapport(s) g√©n√©r√©(s){Colors.RESET}\n")

if __name__ == '__main__':
    main()

